---
layout:     post
title:      JavaSE基础
subtitle:   详解Java基础知识
date:       2018-04-10
author:     Will Wang
header-img: img/post-bg-article.jpg
catalog: true
tags:
    - java
---

#### 1. 方法
##### 1.1 定义方法的完整格式
- 定义方法的完整格式:
    ```
    修饰符 返回值类型 方法名称(参数类型 参数名称, ...) {
        方法体
        return 返回值;
    }
    ```
    1. 修饰符：现阶段的固定写法，public static
    2. 返回值类型：也就是方法最终产生的数据结果是什么类型
    3. 方法名称：方法的名字，规则和变量一样，小驼峰
    4. 参数类型：进入方法的数据是什么类型
    5. 参数名称：进入方法的数据对应的变量名称<br/>
    PS：参数如果有多个，使用逗号进行分隔
    6. 方法体：方法需要做的事情，若干行代码
    7. return：两个作用，第一停止当前方法，第二将后面的返回值还给调用处
    8. 返回值：也就是方法执行后最终产生的数据结果<br/>
    注意：return后面的“返回值”，必须和方法名称前面的“返回值类型”，保持对应。

- 定义一个两个int数字相加的方法。三要素：
    - 返回值类型：int
    - 方法名称：sum
    - 参数列表：int a, int b

- 方法的三种调用格式。
    1. 单独调用：方法名称(参数);
    2. 打印调用：System.out.println(方法名称(参数));
    3. 赋值调用：数据类型 变量名称 = 方法名称(参数);

注意：此前学习的方法，返回值类型固定写为void，这种方法只能够单独调用，不能进行打印调用或者赋值调用。

##### 1.2 有无参数的方法
- 有参数：小括号当中有内容，当一个方法需要一些数据条件，才能完成任务的时候，就是有参数。 <br/>
例如两个数字相加，必须知道两个数字是各自多少，才能相加。
- 无参数：小括号当中留空。一个方法不需要任何数据条件，自己就能独立完成任务，就是无参数。 <br/>
例如定义一个方法，打印固定10次HelloWorld。

##### 1.3 使用方法注意事项
1. 方法应该定义在类当中，但是不能在方法当中再定义方法。不能嵌套。
2. 方法定义的前后顺序无所谓。
3. 方法定义之后不会执行，如果希望执行，一定要调用：单独调用、打印调用、赋值调用。
4. 如果方法有返回值，那么必须写上“return 返回值;”，不能没有。
5. return后面的返回值数据，必须和方法的返回值类型，对应起来。
6. 对于一个void没有返回值的方法，不能写return后面的返回值，只能写return自己。
7. 对于void方法当中最后一行的return可以省略不写。
8. 一个方法当中可以有多个return语句，但是必须保证同时只有一个会被执行到，两个return不能连写。

##### 1.4 方法的重载
- 对于功能类似的方法来说，因为参数列表不一样，却需要记住那么多不同的方法名称，太麻烦。
- 方法的重载（Overload）：多个方法的名称一样，但是参数列表不一样。
    - 好处：只需要记住唯一一个方法名称，就可以实现类似的多个功能。

1. 方法重载与下列因素相关：
    1. 参数个数不同
    2. 参数类型不同
    3. 参数的多类型顺序不同
2. 方法重载与下列因素无关：
    1. 与参数的名称无关
    2. 与方法的返回值类型无关

#### 2. 数组
##### 2.1 数组的概念与特点
- 数组的概念：是一种容器，可以同时存放多个数据值。
- 数组的特点:
    - 数组是一种引用数据类型
    - 数组当中的多个数据，类型必须统一
    - 数组的长度在程序运行期间不可改变
- 数组的初始化：在内存当中创建一个数组，并且向其中赋予一些默认值。
    - 两种常见的初始化方式：
    1. 动态初始化（指定长度）
    2. 静态初始化（指定内容）
- 动态初始化数组的格式：
数据类型[] 数组名称 = new 数据类型[数组长度];
    - 解析含义：
    1. 左侧数据类型：也就是数组当中保存的数据，全都是统一的什么类型
    1. 左侧的中括号：代表我是一个数组
    1. 左侧数组名称：给数组取一个名字
    1. 右侧的new：代表创建数组的动作
    1. 右侧数据类型：必须和左边的数据类型保持一致
    1. 右侧中括号的长度：也就是数组当中，到底可以保存多少个数据，是一个int数字

##### 2.2 动态初始化与静态初始化
- 动态初始化（指定长度）：在创建数组的时候，直接指定数组当中的数据元素个数。
- 静态初始化（指定内容）：在创建数组的时候，不直接指定数据个数多少，而是直接将具体的数据内容进行指定。
- 静态初始化基本格式：
    - 数据类型[] 数组名称 = new 数据类型[] { 元素1, 元素2, ... };
- 注意事项：
    - 虽然静态初始化没有直接告诉长度，但是根据大括号里面的元素具体内容，也可以自动推算出来长度。

##### 2.3 静态初始化格式
- 使用静态初始化数组的时候，格式还可以省略一下。
- 标准格式：
    - 数据类型[] 数组名称 = new 数据类型[] { 元素1, 元素2, ... };
- 省略格式：
    - 数据类型[] 数组名称 = { 元素1, 元素2, ... };
- 注意事项：
    1. 静态初始化没有直接指定长度，但是仍然会自动推算得到长度。
    2. 静态初始化标准格式可以拆分成为两个步骤。
    3. 动态初始化也可以拆分成为两个步骤。
    4. 静态初始化一旦使用省略格式，就不能拆分成为两个步骤了。
- 使用建议：
    - 如果不确定数组当中的具体内容，用动态初始化；否则，已经确定了具体的内容，用静态初始化。

##### 2.4 数组索引
- 数组的索引编号从0开始，一直到“数组的长度-1”为止。        
- 如果访问数组元素的时候，索引编号并不存在，那么将会发生
数组索引越界异常
ArrayIndexOutOfBoundsException
- 原因：索引编号写错了。
解决：修改成为存在的正确索引编号。

#### 3. 面向对象
###### 面向过程：当需要实现一个功能的时候，每一个具体的步骤都要亲力亲为，详细处理每一个细节。
###### 面向对象：当需要实现一个功能的时候，不关心具体的步骤，而是找一个已经具有该功能的人，来帮我做事儿。
##### 3.1 new对象
- 通常情况下，一个类并不能直接使用，需要根据类创建一个对象，才能使用。
1. 导包：也就是指出需要使用的类，在什么位置。<br>
import 包名称.类名称;<br>
import cn.flyingd.demo01.Student;<br>
对于和当前类属于同一个包的情况，可以省略导包语句不写。
2. 创建，格式：<br>
类名称 对象名 = new 类名称();<br>
Student stu = new Student();<br>
3. 使用，分为两种情况：<br>
使用成员变量：对象名.成员变量名<br>
使用成员方法：对象名.成员方法名(参数)<br>
（也就是，想用谁，就用对象名点儿谁。）<br>
- 注意事项：
    - 如果成员变量没有进行赋值，那么将会有一个默认值，规则和数组一样。

##### 3.2 局部变量和成员变量
1. 定义的位置不一样【重点】<br>
局部变量：在方法的内部<br>
成员变量：在方法的外部，直接写在类当中<br>

2. 作用范围不一样【重点】<br>
局部变量：只有方法当中才可以使用，出了方法就不能再用<br>
成员变量：整个类全都可以通用。<br>

3. 默认值不一样【重点】<br>
局部变量：没有默认值，如果要想使用，必须手动进行赋值<br>
成员变量：如果没有赋值，会有默认值，规则和数组一样<br>

4. 内存的位置不一样（了解）<br>
局部变量：位于栈内存<br>
成员变量：位于堆内存<br>

5. 生命周期不一样（了解）<br>
局部变量：随着方法进栈而诞生，随着方法出栈而消失<br>
成员变量：随着对象创建而诞生，随着对象被垃圾回收而消失<br>

##### 3.3 面向对象三大特征
- 面向对象三大特征：封装、继承、多态
- 封装性在Java当中的体现：
    1. 方法就是一种封装
    2. 关键字private也是一种封装
- 封装就是将一些细节信息隐藏起来，对于外界不可见。

##### 3.4 封装
- 问题描述：定义Person的年龄时，无法阻止不合理的数值被设置进来。
- 解决方案：用private关键字将需要保护的成员变量进行修饰。
- 一旦使用了private进行修饰，那么本类当中仍然可以随意访问。
但是！超出了本类范围之外就不能再直接访问了。
- 间接访问private成员变量，就是定义一对儿Getter/Setter方法
- 必须叫setXxx或者是getXxx命名规则。
    - 对于Getter来说，不能有参数，返回值类型和成员变量对应；
    - 对于Setter来说，不能有返回值，参数类型和成员变量对应。

##### 3.5 构造方法
- 构造方法是专门用来创建对象的方法，当我们通过关键字new来创建对象时，其实就是在调用构造方法。
- 格式：
    ```
    public 类名称(参数类型 参数名称) {
        方法体
    }
    ```
- 注意事项：
    1. 构造方法的名称必须和所在的类名称完全一样，就连大小写也要一样
    2. 构造方法不要写返回值类型，连void都不写
    3. 构造方法不能return一个具体的返回值
    4. 如果没有编写任何构造方法，那么编译器将会默认赠送一个构造方法，没有参数、方法体什么事情都不做。
public Student() {}
    5. 一旦编写了至少一个构造方法，那么编译器将不再赠送。
    6. 构造方法也是可以进行重载的。
重载：方法名称相同，参数列表不同。

##### 3.6 Java Bean
- 一个标准的类通常要拥有下面四个组成部分：
    1. 所有的成员变量都要使用**private**关键字修饰
    2. 为每一个成员变量编写一对儿Getter/Setter方法
    3. 编写一个无参数的构造方法
    4. 编写一个全参数的构造方法
- 这样标准的类也叫做**Java Bean**

#### 4. Scanner类
- Scanner类的功能：可以实现键盘输入数据，到程序当中。
- 引用类型的一般使用步骤：
    1. 导包<br>
import 包路径.类名称;<br>
如果需要使用的目标类，和当前类位于同一个包下，则可以省略导包语句不写。<br>
只有java.lang包下的内容不需要导包，其他的包都需要import语句。<br>
    2. 创建<br>
类名称 对象名 = new 类名称();
    3. 使用<br>
对象名.成员方法名()
- 获取键盘输入的一个int数字：int num = sc.nextInt();
- 获取键盘输入的一个字符串：String str = sc.next();

##### 4.1 new对象格式
- 创建对象的标准格式：
    - 类名称 对象名 = new 类名称();
- 匿名对象就是只有右边的对象，没有左边的名字和赋值运算符。
    - new 类名称();
- 注意事项：匿名对象只能使用唯一的一次，下次再用不得不再创建一个新对象。
- 使用建议：如果确定有一个对象只需要使用唯一的一次，就可以用匿名对象。

#### 5. Random类
- Random类用来生成随机数字。使用起来也是三个步骤：
1. 导包<br>
import java.util.Random;
2. 创建<br>
Random r = new Random(); // 小括号当中留空即可
3. 使用<br>
获取一个随机的int数字（范围是int所有范围，有正负两种）：int num = r.nextInt()<br>
获取一个随机的int数字（参数代表了范围，左闭右开区间）：int num = r.nextInt(3)<br>
实际上代表的含义是：[0,3)，也就是0~2

#### 6. 数组与集合的区别
- 数组的长度不可以发生改变。
- 但是ArrayList集合的长度是可以随意变化的。
- 对于ArrayList来说，有一个尖括号<E>代表泛型。
    - 泛型：也就是装在集合当中的所有元素，全都是统一的什么类型。
    - 注意：泛型只能是引用类型，不能是基本类型。
- 注意事项：
    - 对于ArrayList集合来说，直接打印得到的不是地址值，而是内容。
    - 如果内容是空，得到的是空的中括号：[]

#### 7. 包装类
- 如果希望向集合ArrayList当中存储基本类型数据，必须使用基本类型对应的“包装类”。
    基本类型   | 包装类（引用类型，包装类都位于java.lang包下）
    ---|---
    byte    |     Byte
    short    |    Short
    int       |     Integer     【特殊】
    long       |  Long
    float       |  Float
    double     |Double
    char        | Character   【特殊】
    boolean   |Boolean
- 从JDK 1.5+开始，支持自动装箱、自动拆箱。
    - 自动装箱：基本类型 --> 包装类型
    - 自动拆箱：包装类型 --> 基本类型

#### 8. String类
java.lang.String类代表字符串。<br>
API当中说：Java 程序中的所有字符串字面值（如 "abc" ）都作为此类的实例实现。<br>
其实就是说：程序当中所有的双引号字符串，都是String类的对象。（就算没有new，也照样是。）<br>
- 字符串的特点：
    1. 字符串的内容永不可变。【重点】
    2. 正是因为字符串不可改变，所以字符串是可以共享使用的。
    3. 字符串效果上相当于是char[]字符数组，但是底层原理是byte[]字节数组。

创建字符串的常见3+1种方式。
- 三种构造方法：
    - public String()：创建一个空白字符串，不含有任何内容。
    - public String(char[] array)：根据字符数组的内容，来创建对应的字符串。
    - public String(byte[] array)：根据字节数组的内容，来创建对应的字符串。
- 一种直接创建：
    - String str = "Hello"; // 右边直接用双引号<br>
    注意：直接写上双引号，就是字符串对象。

##### 8.1 String类方法使用
- public int length()：获取字符串当中含有的字符个数，拿到字符串长度。
- public String concat(String str)：将当前字符串和参数字符串拼接成为返回值新的字符串。
- public char charAt(int index)：获取指定索引位置的单个字符。（索引从0开始。）
- public int indexOf(String str)：查找参数字符串在本字符串当中首次出现的索引位置，如果没有返回-1值。
- public String substring(int index)：截取从参数位置一直到字符串末尾，返回新字符串。
- public String substring(int begin, int end)：截取从begin开始，一直到end结束，中间的字符串。<br>
备注：[begin,end)，包含左边，不包含右边。
- public char[] toCharArray()：将当前字符串拆分成为字符数组作为返回值。
- public byte[] getBytes()：获得当前字符串底层的字节数组。
- public String replace(CharSequence oldString, CharSequence newString)：<br>
将所有出现的老字符串替换成为新的字符串，返回替换之后的结果新字符串。<br>
备注：CharSequence意思就是说可以接受字符串类型。
- public String[] split(String regex)：按照参数的规则，将字符串切分成为若干部分。

注意事项：<br>
split方法的参数其实是一个“正则表达式”，今后学习。<br>
今天要注意：如果按照英文句点“.”进行切分，必须写"\\\\."（两个反斜杠）

#### 9. static关键字
如果一个成员变量使用了static关键字，那么这个变量不再属于对象自己，而是属于所在的类。多个对象共享同一份数据。

##### 9.1 static关键字注意事项
- 一旦使用static修饰成员方法，那么这就成为了静态方法。静态方法不属于对象，而是属于类的。
- 如果没有static关键字，那么必须首先创建对象，然后通过对象才能使用它。
- 如果有了static关键字，那么不需要创建对象，直接就能通过类名称来使用它。
- 无论是成员变量，还是成员方法。如果有了static，都推荐使用类名称进行调用。
    - 静态变量：类名称.静态变量
    - 静态方法：类名称.静态方法()
- 注意事项：
    - 静态不能直接访问非静态。<br>
    原因：因为在内存当中是【先】有的静态内容，【后】有的非静态内容。<br>
    “先人不知道后人，但是后人知道先人。”
    - 静态方法当中不能用this。<br>
    原因：this代表当前对象，通过谁调用的方法，谁就是当前对象。

##### 9.2 静态代码块
- 静态代码块的格式是：
    ```
    public class 类名称 {
        static {
            // 静态代码块的内容
        }
    }
    ```
- 特点：当第一次用到本类时，静态代码块执行唯一的一次。<br>
    静态内容总是优先于非静态，所以静态代码块比构造方法先执行。
- 静态代码块的典型用途：
用来一次性地对静态成员变量进行赋值。

#### 10. Math类
- java.util.Math类是数学相关的工具类，里面提供了大量的静态方法，完成与数学运算相关的操作。

public static **double abs**(double num)：获取绝对值。有多种重载。<br>
public static **double ceil**(double num)：向上取整。<br>
public static **double floor**(double num)：向下取整。<br>
public static **long round**(double num)：四舍五入。<br>

- Math.PI代表近似的圆周率常量（double）。

#### 11. 继承
- 在继承的关系中，“子类就是一个父类”。也就是说，子类可以被当做父类看待。
    - 例如父类是员工，子类是讲师，那么“讲师就是一个员工”。关系：is-a。
- 定义父类的格式：（一个普通的类定义）
    ```
    public class 父类名称 {
        // ...
    }
    ```
- 定义子类的格式：
    ```
    public class 子类名称 extends 父类名称 {
    // ...
    }
    ```
##### 11.1 继承访问成员变量
- 在父子类的继承关系当中，如果成员变量重名，则创建子类对象时，访问有两种方式：
    - 直接通过子类对象访问成员变量：
        - 等号左边是谁，就优先用谁，没有则向上找。
    - 间接通过成员方法访问成员变量：
        - 该方法属于谁，就优先用谁，没有则向上找。

##### 11.2 继承中变量的访问
- 局部变量：         直接写成员变量名
- 本类的成员变量：    this.成员变量名
- 父类的成员变量：    super.成员变量名

##### 11.3 继承中方法重写
- 在父子类的继承关系当中，创建子类对象，访问成员方法的规则：
    - 创建的对象是谁，就优先用谁，如果没有则向上找。
- 注意事项：
    - 无论是成员方法还是成员变量，如果没有都是向上找父类，绝对不会向下找子类的。
- 重写（Override）
    - 概念：在继承关系当中，方法的名称一样，参数列表也一样。
    - 重写（Override）：方法的名称一样，参数列表【也一样】。覆盖、覆写。
    - 方法的覆盖重写特点：创建的是子类对象，则优先用子类方法。
- 重载（Overload）：方法的名称一样，参数列表【不一样】。

##### 11.4 方法覆盖重写的注意事项
1. 必须保证父子类之间方法的名称相同，参数列表也相同。
    - @Override：写在方法前面，用来检测是不是有效的正确覆盖重写。
    - 这个注解就算不写，只要满足要求，也是正确的方法覆盖重写。
2. 子类方法的返回值必须【小于等于】父类方法的返回值范围。
    - 小扩展提示：java.lang.Object类是所有类的公共最高父类（祖宗类），java.lang.String就是Object的子类。
3. 子类方法的权限必须【大于等于】父类方法的权限修饰符。
    - 小扩展提示：public > protected > (default) > private
    - 备注：(default)不是关键字default，而是什么都不写，留空。

##### 11.5 继承中构造方法访问
- 继承关系中，父子类构造方法的访问特点：
    1. 子类构造方法当中有一个默认隐含的“super()”调用，所以一定是先调用的父类构造，后执行的子类构造。
    2. 子类构造可以通过super关键字来调用父类重载构造。
    3. super的父类构造调用，必须是子类构造方法的第一个语句。不能一个子类构造调用多次super构造。
- 总结：
    - 子类必须调用父类构造方法，不写则赠送super()；
    - 写了则用写的指定的super调用，super只能有一个，还必须是第一个。

#### 12. 抽象
- 抽象方法：就是加上abstract关键字，然后去掉大括号，直接分号结束。
- 抽象类：抽象方法所在的类，必须是抽象类才行。在class之前写上abstract即可。
- 如何使用抽象类和抽象方法：
    1. 不能直接创建new抽象类对象。
    2. 必须用一个子类来继承抽象父类。
    3. 子类必须覆盖重写抽象父类当中所有的抽象方法。<br>
    覆盖重写（实现）：子类去掉抽象方法的abstract关键字，然后补上方法体大括号。
    4. 创建子类对象进行使用。

#### 13. 接口
- 接口就是多个类的公共规范。
- 接口是一种引用数据类型，最重要的内容就是其中的：抽象方法。
- 如何定义一个接口的格式：
    ```
    public interface 接口名称 {
        // 接口内容
    }
    ```
- 备注：换成了关键字interface之后，编译生成的字节码文件仍然是：.java --> .class。
- 如果是Java 7，那么接口中可以包含的内容有：
    1. 常量
    2. 抽象方法
- 如果是Java 8，还可以额外包含有：
    3. 默认方法
    4. 静态方法
- 如果是Java 9，还可以额外包含有：
    5. 私有方法
- 接口使用步骤：
    1. 接口不能直接使用，必须有一个“实现类”来“实现”该接口。<br>
    格式：
        ```
        public class 实现类名称 implements 接口名称 {
            // ...
        }
        ```
    2. 接口的实现类必须覆盖重写（实现）接口中所有的抽象方法。<br>
    实现：去掉abstract关键字，加上方法体大括号。
    3. 创建实现类的对象，进行使用。
- 注意事项：
    - 如果实现类并没有覆盖重写接口中所有的抽象方法，那么这个实现类自己就必须是抽象类。

##### 13.1 接口实现重点
1. 接口的默认方法，可以通过接口实现类对象，直接调用。
2. 接口的默认方法，也可以被接口实现类进行覆盖重写。

##### 13.2 接口中静态方法的调用
- 注意事项：不能通过接口实现类的对象来调用接口当中的静态方法。
- 正确用法：通过接口名称，直接调用其中的静态方法。
- 格式：
    - 接口名称.静态方法名(参数);

##### 13.3 接口中定义抽象方法
- 在任何版本的Java中，接口都能定义抽象方法。
- 格式：
public abstract 返回值类型 方法名称(参数列表);
- 注意事项：
    1. 接口当中的抽象方法，修饰符必须是两个固定的关键字：public abstract
    2. 这两个关键字修饰符，可以选择性地省略。（今天刚学，所以不推荐。）
    3. 方法的三要素，可以随意定义。

##### 13.4 接口中的常量
- 接口当中也可以定义“成员变量”，但是必须使用public static final三个关键字进行修饰。
- 从效果上看，这其实就是接口的【常量】。
- 格式：
public static final 数据类型 常量名称 = 数据值;
- 备注：
一旦使用final关键字进行修饰，说明不可改变。
- 注意事项：
    1. 接口当中的常量，可以省略public static final，注意：不写也照样是这样。
    2. 接口当中的常量，必须进行赋值；不能不赋值。
    3. 接口中常量的名称，使用完全大写的字母，用下划线进行分隔。（推荐命名规则）

##### 13.5 接口定义默认方法
- 从Java 8开始，接口里允许定义默认方法。
- 格式
    ```
    public default 返回值类型 方法名称(参数列表) {
        方法体
    }
    ```
- 备注：接口当中的默认方法，可以解决接口升级的问题。
- 【私有方法】
    - 问题描述：
        - 我们需要抽取一个共有方法，用来解决两个默认方法之间重复代码的问题。
        - 但是这个共有方法不应该让实现类使用，应该是私有化的。
    - 解决方案：
        - 从Java 9开始，接口当中允许定义私有方法。
        1. 普通私有方法，解决多个默认方法之间重复代码问题
            - 格式
            ```
            private 返回值类型 方法名称(参数列表) {
                方法体
            }
            ```
        2. 静态私有方法，解决多个静态方法之间重复代码问题
            - 格式：
            ```
            private static 返回值类型 方法名称(参数列表) {
                方法体
            }
            ```


##### 13.6 接口定义静态方法
- 从Java 8开始，接口当中允许定义静态方法。
- 格式：
    ```
    public static 返回值类型 方法名称(参数列表) {
        方法体
    }
    ```
- 提示：就是将abstract或者default换成static即可，带上方法体。

##### 13.7 接口使用注意事项
1. 接口是没有静态代码块或者构造方法的。
2. 一个类的直接父类是唯一的，但是一个类可以同时实现多个接口。
    - 格式：
    ```
    public class MyInterfaceImpl implements MyInterfaceA, MyInterfaceB {
        // 覆盖重写所有抽象方法
    }
    ```
3. 如果实现类所实现的多个接口当中，存在重复的抽象方法，那么只需要覆盖重写一次即可。
4. 如果实现类没有覆盖重写所有接口当中的所有抽象方法，那么实现类就必须是一个抽象类。
5. 如果实现类锁实现的多个接口当中，存在重复的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写。
6. 一个类如果直接父类当中的方法，和接口当中的默认方法产生了冲突，优先用父类当中的方法。

##### 13.8 类与接口的关系
1. 类与类之间是单继承的。直接父类只有一个。
2. 类与接口之间是多实现的。一个类可以实现多个接口。
3. 接口与接口之间是多继承的。

- 注意事项：
    1. 多个父接口当中的抽象方法如果重复，没关系。
    2. 多个父接口当中的默认方法如果重复，那么子接口必须进行默认方法的覆盖重写，【而且带着default关键字】。

#### 14. 多态
- 代码当中体现多态性，其实就是一句话：父类引用指向子类对象。
- 格式：<br>
    父类名称 对象名 = new 子类名称();<br>
    或者：<br>
    接口名称 对象名 = new 实现类名称();<br>

##### 14.1 多态访问
- 在多态的代码当中，成员方法的访问规则是：
    - 看new的是谁，就优先用谁，没有则向上找。
- 口诀：编译看左边，运行看右边。
- 对比一下：
    - 成员变量：编译看左边，运行还看左边。
    - 成员方法：编译看左边，运行看右边。

##### 14.2 向上向下转型
- 向上转型一定是安全的，没有问题的，正确的。但是也有一个弊端：
    - 对象一旦向上转型为父类，那么就无法调用子类原本特有的内容。
- 解决方案：用对象的向下转型【还原】。

#### 15. final关键字
- final关键字代表最终、不可改变的。
- 常见四种用法：
    1. 可以用来修饰一个类
    2. 可以用来修饰一个方法
    3. 还可以用来修饰一个局部变量
    4. 还可以用来修饰一个成员变量

##### 15.1 final修饰方法
- 当final关键字用来修饰一个方法的时候，这个方法就是最终方法，也就是不能被覆盖重写。
- 格式：
    ```
    修饰符 final 返回值类型 方法名称(参数列表) {
        // 方法体
    }
    ```
- 注意事项：
    - 对于类、方法来说，abstract关键字和final关键字不能同时使用，因为矛盾。

##### 15.2 final修饰类
- 当final关键字用来修饰一个类的时候，格式：
    ```
    public final class 类名称 {
        // ...
    }
    ```
- 含义：当前这个类不能有任何的子类。（太监类）
- 注意：一个类如果是final的，那么其中所有的成员方法都无法进行覆盖重写（因为没儿子。）

##### 15.3 final修饰成员变量
- 对于成员变量来说，如果使用final关键字修饰，那么这个变量也照样是不可变。

1. 由于成员变量具有默认值，所以用了final之后必须手动赋值，不会再给默认值了。
2. 对于final的成员变量，要么使用直接赋值，要么通过构造方法赋值。二者选其一。
3. 必须保证类当中所有重载的构造方法，都最终会对final的成员变量进行赋值。

#### 16. Java中有四种权限修饰符
范围|public|protected|(default)|private
---|---|---|---|---
同一个类（我自己）|YES|YES|YES|YES
同一个包（我邻居）|YES|YES|YES|NO
不同包子类（我儿子）|YES|YES|NO|NO
不同包非子类（陌生人）|YES|NO|NO|NO

注意事项：(default)并不是关键字“default”，而是根本不写。

#### 17. 内部类
- 如果一个事物的内部包含另一个事物，那么这就是一个类内部包含另一个类。
    - 例如：身体和心脏的关系。又如：汽车和发动机的关系。
- 分类：
    1. 成员内部类
    2. 局部内部类（包含匿名内部类）
- 成员内部类的定义格式：
    ```
    修饰符 class 外部类名称 {
        修饰符 class 内部类名称 {
            // ...
        }
        // ...
    }
    ```
注意：内用外，随意访问；外用内，需要内部类对象。

##### 17.1 成员内部类
- 如何使用成员内部类？有两种方式：
    1. 间接方式：在外部类的方法当中，使用内部类；然后main只是调用外部类的方法。
    2. 直接方式，公式：<br>
    类名称 对象名 = new 类名称();

【外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称();】

##### 17.2 局部内部类1
- 局部内部类，如果希望访问所在方法的局部变量，那么这个局部变量必须是【有效final的】。
- 备注：从Java 8+开始，只要局部变量事实不变，那么final关键字可以省略。
- 原因：
    1. new出来的对象在堆内存当中。
    2. 局部变量是跟着方法走的，在栈内存当中。
    3. 方法运行结束之后，立刻出栈，局部变量就会立刻消失。
    4. 但是new出来的对象会在堆当中持续存在，直到垃圾回收消失。

##### 17.3 局部内部类2
- 如果一个类是定义在一个方法内部的，那么这就是一个局部内部类。
- “局部”：只有当前所属的方法才能使用它，出了这个方法外面就不能用了。
- 定义格式：
    ```
    修饰符 class 外部类名称 {
        修饰符 返回值类型 外部类方法名称(参数列表) {
            class 局部内部类名称 {
                // ...
            }
        }
    }
    ```

##### 17.4 类的权限修饰符
- public > protected > (default) > private
- 定义一个类的时候，权限修饰符规则：
    1. 外部类：public / (default)
    2. 成员内部类：public / protected / (default) / private
    3. 局部内部类：什么都不能写

##### 17.5 匿名内部类
- 如果接口的实现类（或者是父类的子类）只需要使用唯一的一次，
那么这种情况下就可以省略掉该类的定义，而改为使用【匿名内部类】。
- 匿名内部类的定义格式：
    ```
        接口名称 对象名 = new 接口名称() {
            // 覆盖重写所有抽象方法
        };
    ```
- 对格式“new 接口名称() {...}”进行解析：
    1. new代表创建对象的动作
    2. 接口名称就是匿名内部类需要实现哪个接口
    3. {...}这才是匿名内部类的内容
- 另外还要注意几点问题：
    1. 匿名内部类，在【创建对象】的时候，只能使用唯一一次。<br>
    如果希望多次创建对象，而且类的内容一样的话，那么就需要使用单独定义的实现类了。
    2. 匿名对象，在【调用方法】的时候，只能调用唯一一次。<br>
    如果希望同一个对象，调用多次方法，那么必须给对象起个名字。
    3. 匿名内部类是省略了【实现类/子类名称】，但是匿名对象是省略了【对象名称】<br>
    强调：匿名内部类和匿名对象不是一回事！！！

 

